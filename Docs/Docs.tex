\documentclass[a4paper,12pt]{book}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[polish]{babel}
\usepackage[unicode]{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage{tabto}
\usepackage{graphicx}
\usepackage{pythonhighlight}
\usepackage{amsmath}
\usepackage{float}
\usepackage[margin=1.5cm]{geometry}
\usepackage{titlesec}

\newcommand{\sectionbreak}{\clearpage}

\hypersetup{
	colorlinks=true,
	linkcolor=ForestGreen,
	filecolor=YellowOrange,      
	urlcolor=BrickRed,
}
\graphicspath{ {./images/} }

\title{\Large{\textbf{Przetwarzanie Obrazów: Sprawozdanie}}}
\author{Damian Ubowski}
\date{Warszawa, 2020}

\begin{document}
\maketitle
\tableofcontents

\chapter{Wstęp}
\section{Format obrazu}
Wybranym formatem obrazów cyfrowych jest PNG \textit{(ang. The Portable Network Graphics)}, a jego możliwości sprowadzają się do: obsługi kanału alfa (w celu imitacji przezroczystości obrazu), korekcji gamma (w celu dostosowania jasności obrazu), czymś co nazywa się \textit{two-dimensional interlacing}, oraz dobrej jakości kompresję bezstratną, która w porównaniu wypada lepiej na korzyść PNG, a nie GIF. Natomiast wybrany format PNG nie wspiera żadnego rodzaju animacji, co jest korzyścią dla GIF. \\
PNG jest formatem rastrowym co oznacza, że jego strukturę można sprowadzić do dwuwymiarowej tablicy (macierzy) w której komórkach (pikselach) trzymane są wartości dotyczące kolorów. 

\subsection*{Struktura formatu}
Pliki PNG rozpoczynają się od swojej ``Magic number'' potwierdzającej rodzaj pliku i mającej wartość \textit{137 80 78 71 13 10 26 10}. Następnie czerpiąc inspirację ze struktury IFF \textbf{(Interchange File Format)} plik dzieli się na kawałki (\textit{ang. chunks}) zawierające interesujące nas cenne dane - takie jak szerokość lub wysokość obrazu, dpi, informacje o kolorach, rozmieszczeniu pikseli, etc. \\
Każda informacja jest włożona pomiędzy parę \textit{IHDR}-\textit{IEND}. Każdy kawałek składając się z długości, typu i danych, a nad jego integralnością sprawuję pieczę suma kontrolna \textit{CRC}. Wszystko to tworzy zwarty format. \\
Identyfikator typu określa rolę w jakiej przyjdzie służyć kawałkowi. 

\subsection*{Przykładowa struktura prostego pliku PNG}
\begin{figure}[H]
	\includegraphics[width=1\textwidth]{./overview/examplePNG.png}
	\caption{Przykładowa struktura pliku PNG [źródło: wikipedia.org]}
\end{figure}

\section{Instrukcja obsługi programu}
W celu uruchomienia kodu źródłowego będzie niezbędny: 
\begin{itemize}
	\item \href{https://www.python.org/}{Python} ($\geq$ 2.7, 32 bit)
	\item \href{https://numpy.org/}{NumPy} ($\geq$ 1.16.3)
	\item \href{https://matplotlib.org/}{matplotlib} ($\geq$ 2.2.5)
	\item \href{https://pillow.readthedocs.io/en/stable/}{Pillow} ($\geq$ 6.0.0)
\end{itemize}
Uruchomienie programu sprowadza się do użycia komendy \textit{python source.py} w folderze \textit{./Exercises/Source} co spowoduje wygenerowanie się odpowiednich obrazów w folderze \textit{./Exercises/Source/Resources/result}. 

\section{Metody pomocnicze}
W trakcie cyklu wytwarzania tego oprogramowania zostały napisane funkcje mające na celu przyśpieszyć pracę i ujednolicić pewne operacje. Do przykładu takich operacji może się zaliczać wczytanie obrazu z pliku, tworzenie histogramu lub nawet kompozycja nazwy pliku do zapisu. 

\subsection*{Wczytanie obrazu i jego właściwości}
Za odczytanie obrazu z pliku i prze-konwertowaniu go do postaci struktury macierzy dwuwymiarowej odpowiada klasa \textbf{ImageDecoder}. W konstruktorze przyjmuje ona ścieżkę do pliku, który ma zostać wczytany i typ obrazu (obrazy szare podają parametr 'L', a kolorowe 'RGB'). \\
Z pomocą tej klasy możemy odczytać właściwości obrazu, takie jak szerokość (\textbf{getWidth()}) i wysokość (\textbf{getHeight()}) wyrażoną w pikslach. \\
Najważniejszą metodą jest \textbf{getPixels()}, która zwraca macierz obrazu. 
\inputpython{../Source/ImageDecoder.py}{1}{26}

\subsection*{Zapisywanie obrazu i histogramu}
W klasie \textbf{ImageHelper} znajdują się metody statyczne odpowiedzialne za zapisanie wyniku przetwarzania do odpowiedniego folderu w odpowiednim formacie i z właściwą nazwą. \\
Metoda \textbf{Save()} bierze macierz obrazu i jego rodzaj (obraz szaru lub kolorowy - 'L', 'RGB') w celu zapisu. Inne parametry metody potrzebne są aby skonstruować odpowiednią nazwę. Nazwy są tak dobrane, aby pomimo wielu operacji i ich wykonań żaden wynik nie został nadpisany przez inny. Efekt ten jest uzyskiwany głównie dzięki podaniu nazwy operacji, która stanowi podstawę do której doklejane są dalsze informacje - takie jak nazwa pliku wejściowego, wartość parametru i informacja o wystąpieniu normalizacji. \\
Dla przykładu nazwa \textit{divide-color-const-coffee-2-norm.png} składa się z nazwy operacji \textit{divide-color-const} co oznacza, że operacją jest dzielenie obrazu barwnego przez stałą. Drugą informacją jest liczba $2$ dzięki której wiemy, że dzielenie odbyło się przez wartość $2$. Na końcu mamy końcówkę \textit{-norm} mówiącą o tym, że normalizacja wystąpiła dla tego obrazu. \\
Metoda \textbf{SaveGrayHistogram()} i \textbf{SaveColorHistogram()} otrzymuje dane o histogramie i z użyciem biblioteki \textit{matplotlib} tworzy wykres słupkowy. Oprócz argumentóW potrzebnych do utworzenia wykresu należy podać również informacje pozwalające na utworzenie poprawnej nazwy. 
\inputpython{../Source/ImageHelper.py}{1}{59}

\chapter{Operacje ujednolicania obrazów}
Ujednolicanie obrazów oznacza sprowadzenie ich do wspólnego gruntu pod względem określonego parametru. W tym wypadku będziemy ujednolicać obrazy pod względem geometrycznym (ilości kolumn i wierszy pikseli) i następnie rozdzielczościowym (wypełnienia pikselami). Sekwencyjność tych operacji jak i one same nie są w stanie spowodować spadku jakości obrazu. 
\section{Ujednolicenie obrazów szarych geometryczne}
\subsection*{Algorytm}
\subsubsection*{Opis}
Algorytm geometrycznego ujednolicenia obrazów ma za zadanie sprowadzić oba obrazy do tej samej liczby pikseli w każdym wierszu i każdej kolumnie. 

\subsubsection*{Kroki}
\begin{enumerate}
	\item Porównaj szerokości i wysokości obu obrazów i wybierz największe. 
	\item Jeśli pierwszy lub drugi obraz mają szerokość lub wysokość mniejszą od największej dostępnej to:
	\begin{enumerate}
		\item Utwórz czarne tło
		\item Przenieś z wyśrodkowaniem piksle na czarne tło
	\end{enumerate}
	\item Jeśli żaden z warunków jest niespełniony to nie rób nic
\end{enumerate}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (712x712), obraz 2 (1423x1423)}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{cat-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (1423x1423), obraz 2 (1423x1423)}
	\includegraphics[width=8cm, height=8cm]{1-1/geometric-gray-photoman-cat.png}
	\includegraphics[width=8cm, height=8cm]{1-1/geometric-gray-cat-photoman.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (567x567), obraz 2 (712x712)}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (712x712), obraz 2 (712x712)}
	\includegraphics[width=8cm, height=8cm]{1-1/geometric-gray-lena-photoman.png}
	\includegraphics[width=8cm, height=8cm]{1-1/geometric-gray-photoman-lena.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Unification.py}{22}{55}

\section{Ujednolicenie obrazów szarych rozdzielczościowe}
\subsection*{Algorytm}
\subsubsection*{Opis}
Po użyciu ujednolicenia geometrycznego można użyć ujednolicenia rozdzielczościowego, które przeskaluje obraz z mniejszej postaci do większej dzięki czemu nie zostanie nam czarna ramka wokół obrazu. Wynikiem będzie większy obraz niż początkowo bez czarnego obwodu wokół. 
Mniejszy obraz można przeskalować do większych wymiarów przenosząc wszystkie piksele z uwzględnieniem luk pomiędzy nimi i następnie użycia interpolacji do zamazania tych luk. 
Interpolacja działa na zasadzie pobierania wartości z okolicznych pikseli i wyciągania z nich średniej, która posłuży jako baza koloru dla nowego piksela. 

\subsubsection*{Kroki}
\begin{enumerate}
	\item Ustalenie nowych wymiarów obrazu
	\item Obliczenie odległości pomiędzy pikselami (\textit{scaleFactoryH, scaleFactoryW})
	\item Naniesienie pikseli z mniejszego obrazu na większy z uwzględnieniem luk
	\item Interpolacja
\end{enumerate}

\begin{figure}[H]
	\caption{Skutki braku interpolacji}
	\begin{center}
		\includegraphics[width=8cm, height=8cm]{1-2/man-without-interpolation.png}
	\end{center}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (1423x1423), obraz 2 (712x712)}
	\includegraphics[width=8cm, height=8cm]{cat-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (1423x1423), obraz 2 (1423x1423)}
	\includegraphics[width=8cm, height=8cm]{1-2/raster-gray-cat-photoman.png}
	\includegraphics[width=8cm, height=8cm]{1-2/raster-gray-photoman-cat.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (567x567), obraz 2 (712x712)}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (712x712), obraz 2 (712x712)}
	\includegraphics[width=8cm, height=8cm]{1-2/raster-gray-lena-photoman.png}
	\includegraphics[width=8cm, height=8cm]{1-2/raster-gray-photoman-lena.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Unification.py}{58}{98}

\section{Ujednolicenie obrazów RGB geometryczne}
\subsection*{Algorytm}
\subsubsection*{Opis}
Algorytm geometrycznego ujednolicenia obrazów ma za zadanie sprowadzić oba obrazy do tej samej liczby pikseli w każdym wierszu i każdej kolumnie. 
Różnica pomiędzy tym przypadkiem a szarym sprawia, że ważne jest użycie odpowiednich struktur danych w taki sposób aby każdy z kanałów RGB był w stanie się pomieścić. Niewątpliwie ważne jest struktura danych uwzględniała kolejność w jakim kolory są przechowywane, inaczej może dojść do sytuacji w której nie dostaniemy oczekiwanego rezultatu. 

\subsubsection*{Kroki}
\begin{enumerate}
	\item Porównaj szerokości i wysokości obu obrazów i wybierz największe. 
	\item Jeśli pierwszy lub drugi obraz mają szerokość lub wysokość mniejszą od największej dostępnej to:
	\begin{enumerate}
		\item Utwórz czarne tło
		\item Przenieś z wyśrodkowaniem piksle na czarne tło z uwzględnieniem każdego z kanałów RGB
	\end{enumerate}
	\item Jeśli żaden z warunków jest niespełniony to nie rób nic
\end{enumerate}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (128x128), obraz 2 (256x256)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (256x256), obraz 2 (256x256)}
	\includegraphics[width=8cm, height=8cm]{1-3/geometric-color-phone-coffee.png}
	\includegraphics[width=8cm, height=8cm]{1-3/geometric-color-coffee-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 3 (256x256), obraz 4 (512x512)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 3 (512x512), obraz 4 (512x512)}
	\includegraphics[width=8cm, height=8cm]{1-3/geometric-color-phone-sea.png}
	\includegraphics[width=8cm, height=8cm]{1-3/geometric-color-sea-phone.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Unification.py}{101}{132}

\section{Ujednolicenie obrazów RGB rozdzielczościowe}
\subsection*{Algorytm}
\subsubsection*{Opis}
Po użyciu ujednolicenia geometrycznego można użyć ujednolicenia rozdzielczościowego, które przeskaluje obraz z mniejszej postaci do większej dzięki czemu nie zostanie nam czarna ramka wokół obrazu. Wynikiem będzie większy obraz niż początkowo bez czarnego obwodu wokół. 
Mniejszy obraz można przeskalować do większych wymiarów przenosząc wszystkie piksele z uwzględnieniem luk pomiędzy nimi i następnie użycia interpolacji do zamazania tych luk. 
Interpolacja działa na zasadzie pobierania wartości z okolicznych pikseli i wyciągania z nich średniej, która posłuży jako baza koloru dla nowego piksela. 

\subsubsection*{Kroki}
\begin{enumerate}
	\item Ustalenie nowych wymiarów obrazu
	\item Obliczenie odległości pomiędzy pikselami (\textit{scaleFactoryH, scaleFactoryW})
	\item Naniesienie pikseli z mniejszego obrazu na większy z uwzględnieniem luk
	\item Interpolacja
\end{enumerate}

\begin{figure}[H]
	\caption{Skutki braku interpolacji}
	\begin{center}
		\includegraphics[width=8cm, height=8cm]{1-4/phone-without-interpolation.png}
	\end{center}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 1 (128x128), obraz 2 (256x256)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (256x256), obraz 2 (256x256)}
	\includegraphics[width=8cm, height=8cm]{1-4/raster-color-phone-coffee.png}
	\includegraphics[width=8cm, height=8cm]{1-4/raster-color-coffee-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (od lewej): obraz 3 (256x256), obraz 4 (512x512)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po uruchomieniem algorytmu (od lewej): obraz 1 (512x512), obraz 2 (512x512)}
	\includegraphics[width=8cm, height=8cm]{1-4/raster-color-phone-sea.png}
	\includegraphics[width=8cm, height=8cm]{1-4/raster-color-sea-phone.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Unification.py}{135}{177}

\chapter{Operacje sumowania arytmetycznego obrazów szarych}
Obraz jest macierzą wartości co pozwala nam wykonywać na nich operacje arytmetyczne tak samo jak na zwykłych macierzach. 
Operacje takie jak: 
\renewcommand{\labelitemi}{$*$}
\begin{itemize}
	\item dodawanie,
	\item odejmowanie,
	\item mnożenie (wyjątkowo wykonywane inaczej niż w przypadku dwóch macierzy),
	\item dzielenie
\end{itemize}
obrazów może odbywać się w różnych kombinacjach rodzajów wartości: 
\renewcommand{\labelitemi}{$*$}
\begin{itemize}
	\item obraz z obrazem
	\item obraz ze stałą
\end{itemize}
Operacje te odbywają się na poziomie komórek macierz i są też nazywane \textbf{operatorami punktowymi}. Co oznacza, że przy przetwarzaniu dwóch obrazów liczą się tylko wartości znajdujące się na tej samej pozycji wysokości i szerokości w obrazie $P_1(i,j)$ i $P_2(i,j)$. 
\\
Po przeprowadzeniu niektórych operacji algebraicznych należy przeprowadzić normalizację w celu zmiany zakresu wartości \textit{(min, max)} na \textit{(newMin, newMax)}. 
Do przeprowadzenia normalizacji w poniższych przykładach będziemy używać wzoru: 
\[f_{norm}=Z_{rep}[(f-f_{min})/(f_{max}-f_{min})]\]
Gdzie $Z_{rep}$ oznacza maksymalną wartość dla naszej struktury piksela. Dla obrazów szarych może przybrać wartość \textit{\#FF} (system szesnastkowy) lub dla wersji kolorowej \textit{\#FFFFFF}. 
W celu uniknięcia powtórzeń w kodzie źródłowym wydzieliłem funkcję normalizacji, która dla obrazów szarych prezentuje się następująco: 
\inputpython{../Source/Commons.py}{8}{15}

\section{Sumowanie określonej stałej z obrazem}
\subsection*{Algorytm}
\subsubsection*{Opis}
W operacji sumowania obrazów szarych ze stałą ważne jest doprowadzenie do stanu w którym będziemy mogli dodać wartość 
nie martwiąc się o przepełnienie zmiennej co mogłoby spowodować zniekształcenie obrazu. \\
Aby tego uniknąć przeskalujemy wszystkie wartości macierzy obrazu tak, aby suma stałej i największej wartości macierzy 
nie przekroczyła maksymalnej wartości dla zmiennej. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po dodaniu wartości 30 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-30.png}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-30-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po dodaniu wartości 300 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-300.png}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-300-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po dodaniu wartości 30 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-30-2.png}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-30-norm-2.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po dodaniu wartości 300 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-300-2.png}
	\includegraphics[width=5cm, height=5cm]{2/sum-gray-const-300-norm-2.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{18}{35}

\section{Sumowanie dwóch obrazów}
\subsection*{Algorytm}
\subsubsection*{Opis}
Dodanie dwóch obrazów jest analogiczne jak przy dodaniu stałej do obrazu, ale z tą różnicą, że maksymalnej wartości mogącej spowodować przepełnienie szukamy we wstępnym obrazie wynikowym sumy obu obrazów. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po dodaniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{lena-unmodified.png}
	\includegraphics[width=7cm, height=7cm]{2/sum-gray-images.png}
	\includegraphics[width=7cm, height=7cm]{2/sum-gray-images-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po dodaniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{cat-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{2/sum-gray-images-2.png}
	\includegraphics[width=7cm, height=7cm]{2/sum-gray-images-2-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{38}{59}

\section{Mnożenie obrazu przez zadaną liczbę}
\subsection*{Algorytm}
\subsubsection*{Opis}
Mnożenie obrazu przychodzi w dwóch formach. Jednym z nich jest wykonanie tej operacji z użyciem stałej jako mnożnika. Na wykonanie tej czynności składa się mnożenie każdego z pikseli przez stałą, w ten sam sposób jak przy zwykłych macierzach: \\
$
\begin{bmatrix}
a_{11} & a_{12} & a_{13}\\
a_{21} & a_{22} & a_{23}\\
a_{31} & a_{32} & a_{33}
\end{bmatrix}
* X = 
\begin{bmatrix}
a_{11} * X & a_{12} * X & a_{13} * X\\
a_{21} * X & a_{22} * X & a_{23} * X\\
a_{31} * X & a_{32} * X & a_{33} * X
\end{bmatrix}
$
\\\\
Mnożeniem obrazów szarych można nazwać też ich \textit{skalowaniem} i dla wartości $\{x: 1 < x\}$ rozjaśnij go. 
Jednym z zagrożeń przy tej operacji jest przepełnienie, które objawia się czarnymi plamami (Rysunek 3.7). Aby go uniknąć dla wartości powyżej  $Z_{rep}$ (tzn. maksymalna wielkość zakresu reprezentacji tonalnej obrazu) program przytnie wartości do $Z_{rep}$ co będzie skutkowało coraz jaśniejszymi obrazami, a uniemożliwi czarne plamy. 

\begin{figure}[H]
	\caption{Przykład przekroczenia maksymalnej wartości}
	\includegraphics[width=17cm, height=17cm]{2-2/multiply-gray-const-error.png}
\end{figure}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po pomnożeniu przez wartość 1.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-photoman-15.png}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-photoman-15-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po pomnożeniu przez wartość 3.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-photoman-35.png}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-photoman-35-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po pomnożeniu przez wartość 1.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-cat-15.png}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-cat-15-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po pomnożeniu przez wartość 3.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-cat-35.png}
	\includegraphics[width=5cm, height=5cm]{2-2/multiply-gray-const-cat-35-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{63}{77}

\section{Mnożenie obrazu przez inny obraz}
\subsection*{Algorytm}
\subsubsection*{Opis}
Drugą formą mnożenia obrazu jest sytuacja gdy mnożnikiem jest inny obraz. Operacja ta przebiega analogicznie jak przy stałej, ale z tą różnicą że każdy piksel mnożymy przez odpowiadający mu piksel w drugim obrazie, zgodnie ze wzorem: 
\begin{gather}
	Q(i,j) = P_1(i,j) \times P_2(i,j)
\end{gather}
W zależności od tego jakich wartości w obrazach użyjemy otrzymamy różne rezultaty: 
\begin{enumerate}
	\item Dla dwóch obrazów, które wartości posiadają z przedziału $(0, Z_{rep})$ obrazy będą się na siebie nakładać (Rysunek 3.12 i 3.13). 
	\item Dla obrazów w których jeden z nich jest używany jako maska otrzymamy wyciętą zawartość drugiego obrazu (Rysunek 3.14). 
\end{enumerate}
Przydatną własnością tej operacji jest możliwość wyciągania części wspólnych z obrazów, dzięki czemu wykrywanie ruch na obrazach po-klatkowych jest łatwiejsze. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po przemnożeniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{lena-unmodified.png}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images-2.png}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po przemnożeniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{cat-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images.png}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po przemnożeniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{cat-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{mask-unmodified.png}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images-mask.png}
	\includegraphics[width=7cm, height=7cm]{2/multiply-gray-images-mask.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{80}{95}

\section{Mieszanie obrazów z określonym współczynnikiem}
\subsection*{Algorytm}
\subsubsection*{Opis}
Operator liniowego mieszania przyjmuje dwa obrazy tych samych rozmiarów, co wymaga skalowania geometrycznego, i zwraca liniową kombinację odpowiadających sobie pikseli (tak samo jak w przypadku dodawania). Wynikiem jest efekt przechodzenia obrazu $f$ w obraz $f^\prime$, a jego natężenie ustala się z pomocą specjalnego współczynnika. \\
Współczynnik $\alpha$ jest wartością określaną przez użytkownika z zakresu $[0,1]$. Jego zadaniem jest skalowanie wartości każdego piksela w obu obrazach przed ich połączeniem, dzięki czemu raz mogą być faworyzowane wartości z $f^\prime$ i raz z $f$. \\
Do obliczeń operatora będzie używany wzór: 
\begin{gather}
	f_{result}(i,j) = \alpha \times f(i,j) + (1 - \alpha) \times f^\prime(i,j)
\end{gather}
Wadą mieszania względem dodawania obrazów jest sam proces skalowania wartości pikseli, który sprawia, że przy wybraniu zbyt małej wartości $\alpha$ kontrast między pikselami jest zatracany. Problem występuje głównie, gdy kontrast na samych obrazach jest dość ubogi. Aby podtrzymać kontrast możemy zwiększyć współczynnik $\alpha$ lub zdefiniować odpowiednią maskę dla naszego obrazu. Maska $f_m$ jest rozmiaru $f_{result}$ i składa się z wartości z zakresu $[0, Z_p]$. Każda wartość takiej maski odpowiada współczynnikowi $\alpha$ dla każdego piksela w $f$ i $f^\prime$. Wzór wygląda wtedy tak: 
\begin{gather}
	f_{result}(i,j) = \frac{f_m(i,j)}{Z_p} \times f(i,j) + (1 - \frac{f_m(i,j)}{Z_p}) \times f^\prime(i,j)
\end{gather}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
\end{figure}
\begin{figure}[H]
	\caption{Po mieszaniu o wartość 0.2 (lewy obraz), po mieszaniu o wartość 0.5 (środkowy obraz), po mieszaniu o wartość 0.8 (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{2/blend-gray-images-2.png}
	\includegraphics[width=5cm, height=5cm]{2/blend-gray-images-5.png}
	\includegraphics[width=5cm, height=5cm]{2/blend-gray-images-8.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{98}{114}

\section{Potęgowanie obrazu z zadaną potęgą}
\subsection*{Algorytm}
\subsubsection*{Opis}
Efektem operatora potęgowania jest zmniejszenie lub zwiększenie kontrastu pomiędzy pikselami. W przeciwieństwie do operacji dodawania, która zmniejszała lub zwiększała wartość wszystkich pikseli, potęgowanie wpływa na odległość pomiędzy wartościami na osi. Zachowanie wynika z własności funkcji wykładniczej (Rysunek 3.16) - im mniejsza wartość bazowa tym wolniejszy przyrost, a dla większych szybszy przyrost. 
\begin{figure}[H]
	\caption{Wykres eksponenty}
	\includegraphics[width=10cm, height=10cm]{overview/exponential-curve.png}
\end{figure}
W zależności od dobrania odpowiedniej wartości \textit{wykładnika} możemy: 
\begin{enumerate}
	\item zwiększyć kontrast dla małych jaskrawości; wybierając $\alpha \in (0,1)$. 
	\item zwiększyć kontrast dla dużych jaskrawości; wybierając $\alpha \in (1,\infty)$. 
\end{enumerate}
Obliczając wartości pikseli użyjemy wzoru: 
\begin{gather}
	f_m = f^\alpha
\end{gather}
Po wykonaniu tej operacji będzie potrzebne zastosowanie normalizacji do uwidocznienie wyników. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-4/power-gray-photoman-20.png}
	\includegraphics[width=5cm, height=5cm]{2-4/power-gray-photoman-20-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-4/power-gray-cat-20.png}
	\includegraphics[width=5cm, height=5cm]{2-4/power-gray-cat-20-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumGray.py}{117}{130}

\section{Dzielenie obrazu przez liczbę}
\subsection*{Wstęp}
Operator dzielenia obrazu przez liczbę przyjmuje dwie wartości: macierz obrazu $P_1$ i stałą liczbową $C$ i polega na podzieleniu każdego piksla w obrazie przez stałą. Wynikiem tej operacji będzie liczba zmiennoprzecinkowa, więc należy ją zaokrąglić do najbliższej wartości całkowitej. 
\begin{gather}
	Q(i,j) = P_1(i,j) \div C
\end{gather}
Efektem tej operacji będzie przyciemnienie obrazu i zmniejszenie kontrastu pomiędzy pikselami. Z tego względu po operacji dzielenia warto zastosować \textit{normalizację}, aby wartości stłoczone bliżej zera \textquotedblright rozciągnąć\textquotedblright na cały możliwy przedział wartości od $0$ do $Z_p$. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumGray.py}{133}{146}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-cat-2.png}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-cat-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-photoman-2.png}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-photoman-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 10 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-cat-10.png}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-cat-10-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 10 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-photoman-10.png}
	\includegraphics[width=5cm, height=5cm]{2-5/divide-gray-const-photoman-10-norm.png}
\end{figure}

\section{Dzielenie obrazu przez inny obraz}
\subsection*{Wstęp}
Dzielenie dwóch obrazów odbywa się z pomocą formuły: 
\begin{gather}
	Q(i,j) = P_1(i,j) \div P_2(i,j)
\end{gather}
Aby operacja się powiodła oba obrazy muszą być tych samych rozmiarów, a dla wartości w których dzielnik ma wartość $0$ przyjmuje się że wynikiem dzielenia jest dzielna tego działania. \\
Pierwszy problem pojawia się gdy chcemy zwyczajnie podzielić odpowiadające sobie piksele $P_1$ i $P_2$, gdyż dostaniemy stosunek jednej wartości do drugiej. Wynik takiej operacji będzie bardzo mały jeśli $P_1(i,j) < P_2(i,j)$ lub proporcjonalnie większy jeśli $P_1(i,j) > P_2(i,j)$ co niszczy harmoniczny kontrast piksli i w rezultacie otrzymujemy to co na rysunku poniżej:
\begin{figure}[H]
	\caption{Rezultat dzielenia obrazu przez inny bez zachowania odpowiedniego balansu pomiędzy pikslami}
	\includegraphics[width=8cm, height=8cm]{2-5/divide-gray-error.png}
\end{figure}
Remedium na ten błąd jest znalezienie największej sumy $P_1$ i $P_2$ określonej jako $Q_{max}$. Następnie dla każdej pary odpowiadających sobie piksli używamy wzoru: 
\begin{gather}
	Q(i,j) = (P_1(i,j) + P_2(i,j)) \times \frac{Z_p}{Q_{max}}
\end{gather}
Wzór ten pozwoli na zachowanie odpowiednich zależności pomiędzy wartościami piksli. \\
Jednym z częstszych zastosowań dzielenia obrazów jest wykrywanie zmian (np w filmach po-klatkowych), w podobny sposób jak używane jest odejmowanie obrazów w tym celu. Ponad to dzielenie obrazów nie może zostać użyte jako operacja maskowania przy użyciu odpowiedniego drugiego obrazu - w przeciwieństwie do operacji mnożenia

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumGray.py}{149}{170}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po podzieleniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{cat-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{2-5/divide-gray-images-cat-photoman.png}
	\includegraphics[width=7cm, height=7cm]{2-5/divide-gray-images-cat-photoman-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po podzieleniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{man-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{lena-unmodified.png}
	\includegraphics[width=7cm, height=7cm]{2-5/divide-gray-images-photoman-lena.png}
	\includegraphics[width=7cm, height=7cm]{2-5/divide-gray-images-photoman-lena-norm.png}
\end{figure}

\section{Pierwiastkowanie obrazu}
\subsection*{Wstęp}
Pierwiastkowanie obrazu jest szczególnym rodzajem jego potęgowania gdy wykładnik potęgi jest mniejszy od jedności. Efektem tej operacji jest zwiększenie intensywności piksli, których wartości są bliższe zeru (tzn. zwiększenie kontrastu) i jednocześnie zmalenie intensywności piksli wyższych pasm (tzn. zmniejszenie kontrastu). Po operacji zwykle jest niezbędna normalizacja ze względu na ciemniejszy wąski zakres wartości obrazu wyjściowego. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumGray.py}{173}{186}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu pierwiastkowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-cat-2.png}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-cat-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu pierwiastkowania o wykładniku 4 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-cat-4.png}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-cat-4-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu pierwiastkowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-photoman-2.png}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-photoman-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu pierwiastkowania o wykładniku 4 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-photoman-4.png}
	\includegraphics[width=5cm, height=5cm]{2-6/root-gray-photoman-4-norm.png}
\end{figure}

\section{Logarytmowanie obrazu}
\subsection*{Wstęp}
Przydatność tej operacji wynika z jej efektu. Polega on na rozjaśnieniu i zwiększeniu kontrastu w ciemniejszych rejonach obrazu. Ten efekt bierze się z kompresji \textit{rozpiętości tonalnej} z użyciem funkcji logarytmicznej. Każdy piksel w obrazie jest zamieniany ze swoim logarytmem. Użycie tego operatora punktowego może być przydatne gdy \textit{rozpiętość tonalna} jest zbyt duża aby ją wyświetlić na ekranie. \\
\textbf{Logarytmowanie obrazu} odbywa się z pomocą wzoru, który uwzględnia nieograniczoność logarytmu w zerze poprzez dodanie wartości w argumencie logarytmu: 
\begin{gather}
	f_m = log(1 + f)
\end{gather}
Przy logarytmowaniu wartości piksli nie trudno o wyjście poza zakres, więc z tego powodu będziemy używać znormalizowanej wersji wzoru: 
\begin{gather}
	f_m = 255 * \left( \frac{log(1 + f(i,j))}{log(1 + f_{max})}\right)
\end{gather}
W tych przykładach będziemy używać logarytmu o bazie $10$, ale można też używać tego z podstawą naturalną gdyż nie wpływa to na kształt krzywej logarytmu. Jedyne co na niego wpływa to scala (wartość 255), która jest stosowana na każdą wartość wychodzącą z logarytmu. Użycie tej skali jest wymagane, aby prawidłowo wyświetlić obraz w systemie 8-bitowym. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumGray.py}{189}{201}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu logarytmu (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{man-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-7/logarithm-gray-photoman.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu logarytmu (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{cat-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{2-7/logarithm-gray-cat.png}
\end{figure}


\chapter{Operacje sumowania arytmetycznego obrazów barwowych}
Rodzaje operatorów arytmetycznych używane na obrazach barwowych różnią się względem ich szarych odpowiedników tylko strukturą na której pracują. Piksel obrazów szarych składa się z jednej wartości z zakresu $[0,255]$. W przypadku kolorowych obrazów potrzebne są trzy wartości na każdą barwę \textit{RGB}. 
\\
Funkcja normalizacji w przypadku tego rodzaju obrazu wygląda tak: 
\inputpython{../Source/Commons.py}{8}{15}
Pobiera ona informacje o maksymalnej dostępnej wartości dla kanału piksela $maxValue$ (w tym wypadku 255). Po czym wśród wszystkich pikselach i ich składowych znajduje najmniejszą i największą wartość $fmin$ i $fmax$. Następnie wykonywane są obliczenia mające na celu przeskalowanie wartości do innego przedziału. W wypadku gdy $fmin$ i $fmax$ znajdują się niedaleko od siebie, normalizacja zapewni aby wartości obrazu wynikowego będą rozpięte na przedział $[0,255]$ z $fmin$ i $fmax$, który może być mniejszy (np z zakresu $[50,90]$). Dzięki temu zabiegowi proporcje między barwami zostaną zachowane i obraz ożywi się trochę kolorami. 

\section{Sumowanie (określonej) stałej z obrazem}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu dodawania o wartości 30 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-coffee-30.png}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-coffee-30-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu dodawania o wartości 30 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-phone-30.png}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-phone-30-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu dodawania o wartości 200 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-coffee-200.png}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-coffee-200-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu dodawania o wartości 200 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-phone-200.png}
	\includegraphics[width=5cm, height=5cm]{3-1/sum-color-const-phone-200-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{18}{37}

\section{Sumowanie dwóch obrazów}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed (obrazy na górze), po dodaniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{coffee-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-1/sum-color-images-coffee-phone.png}
	\includegraphics[width=7cm, height=7cm]{3-1/sum-color-images-coffee-phone-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed (obrazy na górze), po dodaniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-1/sum-color-images-phone-sea.png}
	\includegraphics[width=7cm, height=7cm]{3-1/sum-color-images-phone-sea-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{40}{63}

\section{Mnożenie obrazu przez zadaną liczbę}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed (lewy obraz), po pomnożeniu przez wartości 1.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-coffee-15.png}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-coffee-15-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed (lewy obraz), po pomnożeniu przez wartości 3.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-coffee-35.png}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-coffee-35-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed (lewy obraz), po pomnożeniu przez wartości 1.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-phone-15.png}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-phone-15-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed (lewy obraz), po pomnożeniu przez wartości 3.5 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-phone-35.png}
	\includegraphics[width=5cm, height=5cm]{3-2/multiply-color-const-phone-35-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{67}{85}

\section{Mnożenie obrazu przez inny obraz}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed (górne obrazy), po pomnożeniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{coffee-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-2/multiply-color-images-coffee-phone.png}
	\includegraphics[width=7cm, height=7cm]{3-2/multiply-color-images-coffee-phone-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed (górne obrazy), po pomnożeniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-2/multiply-color-images-phone-sea.png}
	\includegraphics[width=7cm, height=7cm]{3-2/multiply-color-images-phone-sea-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{88}{104}

\section{Mieszanie obrazów z określonym współczynnikiem}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
\end{figure}
\begin{figure}[H]
	\caption{Po mieszaniu o wartość 0.2 (lewy obraz), po mieszaniu o wartość 0.5 (środkowy obraz), po mieszaniu o wartość 0.8 (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{3-3/blend-color-images-coffee-2.png}
	\includegraphics[width=5cm, height=5cm]{3-3/blend-color-images-coffee-5.png}
	\includegraphics[width=5cm, height=5cm]{3-3/blend-color-images-coffee-8.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{107}{124}

\section{Potęgowanie obrazu (z zadaną potęgą)}
\subsection*{Algorytm}
\subsubsection*{Opis}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-4/power-color-coffee-2.png}
	\includegraphics[width=5cm, height=5cm]{3-4/power-color-coffee-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-4/power-color-phone-2.png}
	\includegraphics[width=5cm, height=5cm]{3-4/power-color-phone-2-norm.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/ArithmeticSumColor.py}{127}{142}

\section{Dzielenie obrazu przez liczbę}
\subsection*{Wstęp}
W wypadku gdy wartość piksla jest skalarem - tak jak w przypadku obrazów kolorowych. Stała $C$ jest dzielona przez każdy z trzech kanałów. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumColor.py}{144}{159}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-coffee-2.png}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-coffee-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-phone-2.png}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-phone-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 10 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-coffee-10.png}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-coffee-10-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem (lewy obraz), po dzieleniu przez wartość 10 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-phone-10.png}
	\includegraphics[width=5cm, height=5cm]{3-5/divide-color-const-phone-10-norm.png}
\end{figure}

\section{Dzielenie obrazu przez inny obraz}
\subsection*{Wstęp}
Jedyna różnica pomiędzy sposobem dzielenia obrazów szarych od barwnych polega na innej wartości piksla, który w przypadku tych drugich jest wektorem trzech wartości. Wymusza to znalezienie maksymalnej sumy na przestrzeni każdej z trzech składowych RGB i na ich podstawie wytyczyć można odpowiednia wartość dzielenia za pomocą wzoru: 
\begin{gather}
	Q(i,j) = (P_1(i,j) + P_2(i,j)) \times \frac{Z_p}{Q_{max}}
\end{gather}

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumColor.py}{162}{197}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po podzieleniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{coffee-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-5/divide-color-images-coffee-phone.png}
	\includegraphics[width=7cm, height=7cm]{3-5/divide-color-images-coffee-phone-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (obrazy na górze), po podzieleniu obrazów (lewy, dolny obraz), po normalizacji (prawy, dolny obraz)}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{3-5/divide-color-images-phone-sea.png}
	\includegraphics[width=7cm, height=7cm]{3-5/divide-color-images-phone-sea-norm.png}
\end{figure}

\section{Pierwiastkowanie obrazu}
\subsection*{Wstęp}
Pierwiastkowanie obrazu jest szczególnym rodzajem jego potęgowania gdy wykładnik potęgi jest mniejszy od jedności. Efektem tej operacji jest zwiększenie intensywności piksli, których wartości są bliższe zeru (tzn. zwiększenie kontrastu) i jednocześnie zmalenie intensywności piksli wyższych pasm (tzn. zmniejszenie kontrastu). Po operacji zwykle jest niezbędna normalizacja ze względu na ciemniejszy wąski zakres wartości obrazu wyjściowego. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumColor.py}{200}{215}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-coffee-2.png}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-coffee-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 4 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-coffee-4.png}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-coffee-4-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 2 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-phone-2.png}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-phone-2-norm.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu potęgowania o wykładniku 4 (środkowy obraz), po normalizacji (prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-phone-4.png}
	\includegraphics[width=5cm, height=5cm]{3-6/root-color-phone-4-norm.png}
\end{figure}

\section{Logarytmowanie obrazu}
\subsection*{Wstęp}
Przydatność tej operacji wynika z jej efektu. Polega on na rozjaśnieniu i zwiększeniu kontrastu w ciemniejszych rejonach obrazu. Ten efekt bierze się z kompresji \textit{rozpiętości tonalnej} z użyciem funkcji logarytmicznej. Każdy piksel w obrazie jest zamieniany ze swoim logarytmem. Użycie tego operatora punktowego może być przydatne gdy \textit{rozpiętość tonalna} jest zbyt duża aby ją wyświetlić na ekranie. \\
\textbf{Logarytmowanie obrazu} odbywa się z pomocą wzoru, który uwzględnia nieograniczoność logarytmu w zerze poprzez dodanie wartości w argumencie logarytmu: 
\begin{gather}
	f_m = log(1 + f)
\end{gather}
Przy logarytmowaniu wartości piksli nie trudno o wyjście poza zakres, więc z tego powodu będziemy używać znormalizowanej wersji wzoru: 
\begin{gather}
	f_m = 255 * \left( \frac{log(1 + f(i,j))}{log(1 + f_{max})}\right)
\end{gather}
W tych przykładach będziemy używać logarytmu o bazie $10$, ale można też używać tego z podstawą naturalną gdyż nie wpływa to na kształt krzywej logarytmu. Jedyne co na niego wpływa to scala (wartość 255), która jest stosowana na każdą wartość wychodzącą z logarytmu. Użycie tej skali jest wymagane, aby prawidłowo wyświetlić obraz w systemie 8-bitowym. 

\subsection*{Kod algorytmu}
\inputpython{../Source/ArithmeticSumColor.py}{218}{234}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu logarytmu(prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{phone-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-7/logarithm-color-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po użyciu logarytmu(prawy obraz)}
	\includegraphics[width=5cm, height=5cm]{coffee-unmodified.jpg}
	\includegraphics[width=5cm, height=5cm]{3-7/logarithm-color-coffee.png}
\end{figure}

\chapter{Operacje geometryczne na obrazie}
Operacje geometryczne przekształcają położenie pikseli \textit{(x1, y1)} w obrazie wejściowym do nowej lokacji \textit{(x2, y2)} w obrazie wynikowym. Dzięki temu możemy dopasować obraz do odpowiedniego układu współrzędnych lub użyć tych operacji do eliminacji geometrycznych zakłóceń obrazu (dystorsji). 

\section{Przemieszczenie obrazu o zadany wektor}
\subsection*{Opis}
Operacja translacji wykonuje transformację geometryczną polegającą na przeniesieniu każdego z punktów obrazu wejściowego w nowe miejsce na obrazie wynikowym. Pod wpływem translacji element obrazu zlokalizowany na \textit{(x1, y1)} zostanie przesunięty na nową pozycję \textit{(x2, y2)}. Różnicą pomiędzy \textit{(x1, y1)} i \textit{(x2, y2)} jest wektor \textit{(bx, by)}, który jest określony przez użytkownika. \\
Operacja przemieszczenia przybiera postać: 
\begin{gather}
	x_2 = x_1 + b_x \\
	y_2 = y_1 + b_y
\end{gather}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po przesunięciu o wektor [100, 100] (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-1/translate-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po przesunięciu o wektor [100, 100] (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-1/translate-sea.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{15}{26}

\section{Jednorodne skalowanie obrazu}
\subsection*{Opis}
Skalowanie jednorodne obrazu składa się na pomnożenie współrzędnych każdego piksela przez określoną wartość. 
\begin{gather}
	x_2 = S_x * x_1 \\
	y_2 = S_y * y_1
\end{gather}
Przy czym skalowanie jednorodne oznacza, że po zmianie wartości współrzędnych nasz obraz zachowa dawne proporcje. Czyli: 
\begin{gather}
	S_x = S_y
\end{gather}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po skalowaniu jednorodnym o współczynnik 2 (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-2/homogeneous-scaling-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po skalowaniu jednorodnym o współczynnik 2 (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-2/homogeneous-scaling-sea.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{29}{36}
\inputpython{../Source/Geometric.py}{48}{55}

\section{Niejednorodne skalowanie obrazu}
\subsection*{Opis}
Skalowanie niejednorodne obrazu składa się na pomnożenie współrzędnych każdego piksela przez określoną wartość. 
\begin{gather}
	x_2 = S_x * x_1 \\
	y_2 = S_y * y_1
\end{gather}
Przy czym skalowanie niejednorodne oznacza, że po zmianie wartości współrzędnych nasz obraz będzie miał zachwiane proporcje. Czyli: 
\begin{gather}
	S_x \neq S_y
\end{gather}

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po skalowaniu jednorodnym o współczynnik x = 2.0, y = 1.0 (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-2/nonuniform-scaling-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po skalowaniu jednorodnym o współczynnik x = 2.0, y = 1.0 (prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-2/nonuniform-scaling-sea.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{39}{55}

\section{Obracanie obrazu o dowolny kąt}
\subsection*{Opis}
Operacja obrotu wykonywana jest wokół początku układu współrzędnych o kąt $\varphi$ w taki sposób aby odległość od początku układu do punktu pozostała bez zmian, oraz aby pomiędzy odcinkami danych punków był kąt $\varphi$. Właściwości te można pozyskać dzięki wzorom: 
\begin{gather}
	x` = x\cos(\varphi) - y\sin(\varphi) \\
	y` = x\sin(\varphi) + y\cos(\varphi)
\end{gather}
gdzie \textit{(x`, y`)} to nowe współrzędne wyznaczone po obrocie punktu \textit{(x, y)} o kąt $\varphi$. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po obróceniu o kąt $45^o$(prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{sea-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-3/rotate-sea.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy obraz), po obróceniu o kąt $45^o$(prawy obraz)}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{4-3/rotate-phone.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{58}{77}

\section{Symetrie względem osi układu}
\subsection*{Opis}
Symetria osiowa względem osi OX lub OY sprawia, że punkt \textit{(x, y)} zmienia się w \textit{(x, -y)} lub \textit{(-x, y)} w zależności czy symetria dotyczyła osi OX lub OY. W tej pracy przyjmuję, że lewa dolna krawędź obrazu znajduje się w punkcie \textit{(0, 0)}. 

\begin{figure}[H]
	\caption{Od lewej: przed uruchomieniem algorytmu, po symetrii względem OX, po symetrii względem OY, po symetrii względem OX oraz OY}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-True-False-sea.png}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-False-True-sea.png}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-True-True-sea.png}
\end{figure}
\begin{figure}[H]
	\caption{Od lewej: przed uruchomieniem algorytmu, po symetrii względem OX, po symetrii względem OY, po symetrii względem OX oraz OY}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-True-False-phone.png}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-False-True-phone.png}
	\includegraphics[width=7cm, height=7cm]{4-4/axis-symmetry-True-True-phone.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{80}{99}

\section{Symetrie względem zadanej prostej}
\subsection*{Opis}
Przypadek podobny do poprzedniego, lecz tym razem użytkownik podaje wiersz lub kolumnę względem której będzie przebiegała oś symetrii. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po symetrii względem prostej \textit{x=356} (środkowy), po symetrii względem prostej \textit{y=356} (prawy)}
	\includegraphics[width=6cm, height=6cm]{sea-unmodified.jpg}
	\includegraphics[width=6cm, height=6cm]{4-4/x-symmetry-sea-356.png}
	\includegraphics[width=6cm, height=6cm]{4-4/y-symmetry-sea-356.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po symetrii względem prostej \textit{x=64} (środkowy), po symetrii względem prostej \textit{y=64} (prawy)}
	\includegraphics[width=6cm, height=6cm]{phone-unmodified.jpg}
	\includegraphics[width=6cm, height=6cm]{4-4/x-symmetry-phone-64.png}
	\includegraphics[width=6cm, height=6cm]{4-4/y-symmetry-phone-64.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{102}{122}
\inputpython{../Source/Geometric.py}{125}{145}

\section{Wycinanie fragmentów obrazu}
\subsection*{Opis}
Wycięcie części obrazu jest zaimplementowane za pomocą kopiowania pikseli do obrazu pomocniczego. Skopiowane zostają tylko te piksle, które znajdują się wewnątrz podanego zakresu. 

\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po wycięciu kwadratu od piksela \textit{(50, 50)} do \textit{(100, 100)} (prawy)}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-5/crop-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po wycięciu kwadratu od piksela \textit{(50, 50)} do \textit{(100, 100)} (prawy)}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-5/crop-sea.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{166}{174}

\section{Kopiowanie fragmentów obrazów}
\subsection*{Opis}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po skopiowaniu kwadratu od piksela \textit{(50, 50)} do \textit{(100, 100)} (prawy)}
	\includegraphics[width=7cm, height=7cm]{phone-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-6/copy-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Przed uruchomieniem algorytmu (lewy), po skopiowaniu kwadratu od piksela \textit{(50, 50)} do \textit{(100, 100)} (prawy)}
	\includegraphics[width=7cm, height=7cm]{sea-unmodified.jpg}
	\includegraphics[width=7cm, height=7cm]{4-6/copy-sea.png}
\end{figure}

\subsection*{Kod źródłowy algorytmu}
\inputpython{../Source/Geometric.py}{177}{187}

\chapter{Operacje na histogramie obrazu szarego}
Histogram obrazu to typ histogramu, który na osi poziomej przyjmuje rozpiętość tonalną obrazu szarego, a na pionowej zliczone występowania wartości tych tonów. Dzięki temu zabiegowi można na jednym wykresie przedstawić rozkład kolorów danego obrazu i odczytać dane o jego jasności i intensywności.  Umożliwia to świadome manipulowanie jego cechami w celu ulepszenia obrazu (zmiana jasności lub kontrastu z pomocą normalizacji) lub uwydatnienia jego cech (na przykład przy progowaniu obrazu). 

\section{Obliczanie histogramu}
\subsection*{Algorytm}
\subsubsection*{Opis}
Przy obliczaniu wartości histogramu należy wziąć pod uwagę zakres jaki mogą przyjmować piksele. Przy obrazie szarym zakres ten wynosi od 0 do 255. Dla każdej liczby całkowitej w tym zakresie jest zliczana ilość jej wystąpień w obrazie co daje nam pełny pogląd jakie wartości w nim dominują.  \\
Na rysunku \ref{fig:man-histogram} można zaobserwować dominujące wartości. Są to głównie jasne odcienie szarości widoczne w tle obrazu, ale można też zobaczyć, że histogram posiada jeden słupek przewyższający inne w ciemniejszym zakresie odcieni - jest to mężczyzna przedstawiony na pierwszym planie fotografii. \\
Natomiast rysunek \ref{fig:lena-histogram} jest bardziej stonowany pod względem rozłożenia pikseli na skali szarości. \\
Ta operacja jest wstępem do następnych ponieważ samo obliczenie histogramu daje inny pogląd na analizę obrazu, ale nie wpływa bezpośrednio na jego cechy. Dopiero operacje świadomie zmieniające wartości histogramu są użyteczne. 

\begin{figure}[H]
	\label{fig:lena-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-lena.png}
\end{figure}
\begin{figure}[H]
	\label{fig:man-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman.png}
\end{figure}
\begin{figure}[H]
	\label{fig:man-bright-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-bright-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman-bright.png}
\end{figure}
\begin{figure}[H]
	\label{fig:cat-bright-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{cat-bright-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-cat-bright.png}
\end{figure}

\subsection*{Kod źródłowy programu}
\inputpython{../Source/Commons.py}{18}{27}

\section{Przemieszczanie histogramu}
\subsection*{Wstęp}
Przemieszczenie histogramu jest efektem po zastosowaniu operatora punktowego, który dodaje lub odejmuje stałą wartość od każdego piksela. Wykres histogramu w tym wypadku przemieszcza się wzdłuż osi OX, zawierającej zakres wartości tonalnej obrazu. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramGray.py}{25}{41}

\subsection*{Wynik algorytmu}
Rozjaśnienie obrazu spowodowało przesunięcie histogramu w prawą stronę, a przyciemnienie go spowodowało efekt odwrotny. \\
W miejscu gdzie wartości chciały wyjść poza dostępny zakres można zaobserwować znaczący wzrost występowania pikseli o wartościach granicznych (0 i 255). 

\begin{figure}[H]
	\label{fig:man-moved-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman.png}
	
	\caption{Po przesunięciu histogramu w górę o 30 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-image-photoman-30.png}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-photoman-30.png}
	
	\caption{Po przesunięciu histogramu w dół o 30 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-image-photoman--30.png}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-photoman--30.png}
\end{figure}
\begin{figure}[H]
	\label{fig:lena-moved-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-lena.png}
	
	\caption{Po przesunięciu histogramu w górę o 30 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-image-lena-30.png}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-lena-30.png}
	
	\caption{Po przesunięciu histogramu w dół o 30 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-image-lena--30.png}
	\includegraphics[width=8cm, height=8cm]{5-2/move-histogram-lena--30.png}
\end{figure}

\section{Rozciąganie histogramu}
\subsection*{Wstęp}
Wyróżnia się dwie metody \textbf{skalowania histogramu}, mogące wpływać na jego kształt. Pierwszą z nich jest \textbf{skalowanie pionowe}, które rozciąga histogram z użyciem operatora mnożenia obrazu przez skalar większy od jedności lub zwęża histogram gdy użyjemy operatora mnożenia z wartością mniejszą od jedności. Drugą jest \textbf{skalowanie poziome}, które przekształci wąski zakres wartości tonalnych do jego odpowiednika o pełnym zakresie. \\
Na przykład jeśli w pewnym obrazie najmniejsza wartość ($min$) wynosi 60, a największa ($max$) wynosi 180 rozciągnięcie histogramu z pomocą \textit{normalizacji} przekształci zbiór $[60,180]$ na $[0,MAX_{ton}]$, czyli w tym wypadku $[0,255]$. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramGray.py}{44}{52}
Używałem tej samej funkcji \textit{normalizacji} co w innych przykładach: 
\inputpython{../Source/Commons.py}{8}{15}

\subsection*{Wynik algorytmu}
Na przedstawionych rysunkach \ref{fig:man-bright-extend-histogram} i \ref{fig:cat-bright-extend-histogram} widać zwiększenie się poziomu kontrastu wraz z rozszerzeniem się histogramu i wykorzystaniem większej gradacji barw. Funkcja \textit{normalizacji} zostawiła tą samą ilość słupków, ale zmieniła ich rozmieszczenie na osi OX. Dzięki temu na zdjęciach wynikowych widać nawet odcienie czerni i brudnej bieli, których obrazy bazowe nie posiadają. 

\begin{figure}[H]
	\label{fig:man-bright-extend-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-bright-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman-bright.png}
	
	\caption{Po rozszerzeniu histogramu z pomocą normalizacji}
	\includegraphics[width=8cm, height=8cm]{5-3/extend-histogram-image-photoman-bright.png}
	\includegraphics[width=8cm, height=8cm]{5-3/extend-histogram-photoman-bright.png}
\end{figure}
\begin{figure}[H]
	\label{fig:cat-bright-extend-histogram}
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{cat-bright-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-cat-bright.png}
	
	\caption{Po rozszerzeniu histogramu z pomocą normalizacji}
	\includegraphics[width=8cm, height=8cm]{5-3/extend-histogram-image-cat-bright.png}
	\includegraphics[width=8cm, height=8cm]{5-3/extend-histogram-cat-bright.png}
\end{figure}

\section{Progowanie lokalne}
\subsection*{Wstęp}
\textbf{Progowanie} jest operatorem służącym do konwersji obrazu szarego lub kolorowego do jego binarnej formy. Jest to też rodzaj \textbf{segmentacji obrazu}, w którym \textit{próg} zależy od wartości danego piksela $f(x,y)$ i od jego lokalnej właściwości $p(x,y)$.  \\
Obrazy binarne posiadają tylko dwie wartości \textit{prawdę} i \textit{fałsz}, więc aby zmienić macierz w której komórki mogą przyjmować więcej niż dwie wartości niezbędne jest ustalenie \textbf{progu jasności}. Liczby większe od progu będą przyjmowały wartość oznaczoną jako \textit{prawda}, a mniejsze bądź równe otrzymają \textit{fałsz}. Inaczej można też powiedzieć, że wartości mniejsze od progu będą tłem, a większe obiektem. W świecie obrazów szarych \textit{prawdą} będzie wartość maksymalna $MAX_{ton}$ czyli $255$, a \textit{fałszem} wartość minimalna $MIN_{ton}$ czyli $0$. \\
Przy \textbf{progowaniu lokalnym} dla każdego piksela ustala się \textit{próg jasności} indywidualnie. W tym przykładzie użyję implementacji progowania Bernsen'a. \\
\textbf{Progowanie Bernsen'a} używa w swojej metodzie jednej z wartości podanej przez użytkownika - \textit{kontrastu progowego l}. Jeżeli \textit{kontrast lokalny ($f_{high} - f_{low}$)} jest większy bądź równy \textit{kontrastowi progowemu}, wtedy \textit{próg T(x,y)} jest ustawiany do średniej wartości maksymalnego i minimalnego elementu w oknie. W przypadku gdy prawdziwe jest stwierdzenie $C(x,y)$ całe sąsiedztwo piksela uznaje się jako obiekt lub tło w zależności od $T(x,y) \geq 128$. 
\begin{gather}
	T(x,y) = \frac{f_{low} + f_{high}}{2}
\end{gather}
\begin{gather}
	C(x,y) = f_{high} - f_{low}<l
\end{gather}

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramGray.py}{55}{97}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-lena.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 5 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-lena-5.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-lena-5.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 15 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-lena-15.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-lena-15.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 25 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-lena-25.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-lena-25.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 50 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-lena-50.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-lena-50.png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 5 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-photoman-5.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-photoman-5.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 15 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-photoman-15.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-photoman-15.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 25 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-photoman-25.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-photoman-25.png}
	
	\caption{Obraz binarny po zastosowaniu progowania Bernstena o kontraście progowym 50 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-image-photoman-50.png}
	\includegraphics[width=8cm, height=8cm]{5-4/local-threshold-photoman-50.png}
\end{figure}

\section{Progowanie globalne}
\subsection*{Wstęp}
Dla \textbf{progowania globalnego} ustala się jeden \textit{próg jasności T}, które ma zastosowanie do wszystkich pikseli w obrazie. Wtedy \textit{progiem jasności} nazywamy wartość, która będzie klinem wbijanym w histogram obrazu dzieląc go na dwie części - część obiektów i tła. \\
Dla wszystkich wartości: 
\begin{enumerate}
	\item $f(x,y) \geq T$ otrzymają wartość obiektu
	\item $f(x,y) < T$ otrzymają wartość tła
\end{enumerate}

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramGray.py}{100}{117}

\subsection*{Wynik algorytmu}
Można zaobserwować zależność pomiędzy wielkością wartości progowej $T$ a ilością detalów w obrazie binarnym. Im wyższe $T$ tym więcej detali, co również oznacza wyższy słupek koloru czarnego na histogramie. 
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{man-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-photoman.png}
	
	\caption{Obraz binarny po zastosowaniu progowania globalnego o wartości 64 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-image-photoman-64.png}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-photoman-64.png}
	
	\caption{Obraz binarny po zastosowaniu progowania globalnego o wartości 128 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-image-photoman-128.png}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-photoman-128.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{lena-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{5-1/calculate-lena.png}
	
	\caption{Obraz binarny po zastosowaniu progowania globalnego o wartości 64 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-image-lena-64.png}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-lena-64.png}
	
	\caption{Obraz binarny po zastosowaniu progowania globalnego o wartości 128 wraz z jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-image-lena-128.png}
	\includegraphics[width=8cm, height=8cm]{5-5/global-threshold-lena-128.png}
\end{figure}

\chapter{Operacje na histogramie obrazu barwowego}
Zasadniczą różnicą w przedstawieniu histogramu obrazu barwowego jest ilość kanałów, które trzeba przetworzyć w celu otrzymania ilości wystąpień różnych tonów barw. Dla każdej barwy RGB należy bowiem z osobna obliczyć histogram w celu wyciągnięcia pełnej informacji o stanie barw obrazu jak i również samo przetwarzanie musi się odbywać z uwzględnieniem tych trzech barw. \\
Ilość barw w typ wypadku jest sposobnością, aby użyć \textit{progowania wielo-progowego}, gdyż na każdą barwę będzie mógł przypadać jeden próg. 

\section{Obliczanie histogramu}
\subsection*{Wstęp}
Obliczenie histogramu obrazu barwnego odbywa się poprzez zliczenie ilości występowania każdej wartości tonalnej dla każdej z trzech barw RGB. Oznacza to, że dla barwy czerwonej będziemy liczyć histogram osobno tak jakbyśmy to robili dla obrazu szarego, z tym wyjątkiem że będzie to powtórzyć również dla koloru zielonego i niebieskiego. 

\subsection*{Kod algorytmu}
\inputpython{../Source/Commons.py}{30}{43}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-dark-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee-dark.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-dark-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone-dark.png}
\end{figure}

\section{Przemieszczanie histogramu}
\subsection*{Wstęp}
Przemieszczanie histogramu odbywa się poprzez zmniejszenie lub zwiększenie wartości dla wszystkich pikseli w obrazie. W ramach piksela mogą zostać zmodyfikowane wartości z trzech barw RGB. Zwiększenie wartość dla trzech barw przyciemni obraz, a zmniejszenie rozjaśni. Przesuwanie histogramu może zostać też zastosowane do pojedynczych barw RGB, gdzie zwiększenie jednej z nich spowoduje dominację przypisanego koloru w pikselach co będzie skutkowało zmianą kolorów pikseli. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{25}{50}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość 50 dla wszystkich barw i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-coffee-(50,50,50).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-coffee-(50,50,50).png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość -50 dla wszystkich barw i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-coffee-(-50,-50,-50).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-coffee-(-50,-50,-50).png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość 50 dla barwy czerwonej i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-coffee-(50,0,0).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-coffee-(50,0,0).png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość 50 dla wszystkich barw i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-phone-(50,50,50).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-phone-(50,50,50).png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość -50 dla wszystkich barw i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-phone-(-50,-50,-50).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-phone-(-50,-50,-50).png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po przesunięciu histogramu o wartość 50 dla barwy czerwonej i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-image-phone-(50,0,0).png}
	\includegraphics[width=8cm, height=8cm]{6-2/move-histogram-phone-(50,0,0).png}
\end{figure}

\section{Rozciąganie histogramu}
\subsection*{Wstęp}
Rozszerzanie histogramu odbywa się w tym przykładzie poprzez \textit{normalizację}. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{52}{61}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-dark-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee-dark.png}
	
	\caption{Po rozszerzeniu histogramu z pomocą normalizacji}
	\includegraphics[width=8cm, height=8cm]{6-3/extend-histogram-image-coffee-dark.png}
	\includegraphics[width=8cm, height=8cm]{6-3/extend-histogram-coffee-dark.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-dark-unmodified.png}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone-dark.png}
	
	\caption{Po rozszerzeniu histogramu z pomocą normalizacji}
	\includegraphics[width=8cm, height=8cm]{6-3/extend-histogram-image-phone-dark.png}
	\includegraphics[width=8cm, height=8cm]{6-3/extend-histogram-phone-dark.png}
\end{figure}

\section{Progowanie 1-progowe lokalne}
\subsection*{Wstęp}
Progowanie 1-progowe lokalne odbywa się w tym przykładzie z pomocą \textit{metody Bernsen'a} zmodyfikowanej pod kątem wielu kanałów formatu RGB. 
\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{63}{106}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]	
	\caption{Obraz po zastosowaniu progowania Bernstena o kontraście progowym 15 wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-4/single-local-threshold-image-coffee-15.png}
	\includegraphics[width=8cm, height=8cm]{6-4/single-local-threshold-coffee.png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]	
	\caption{Obraz po zastosowaniu progowania Bernstena o kontraście progowym 15 wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-4/single-local-threshold-image-phone-15.png}
	\includegraphics[width=8cm, height=8cm]{6-4/single-local-threshold-phone.png}
\end{figure}

\section{Progowanie wielo-progowe lokalne}
\subsection*{Wstęp}
Progowanie wielo-progowe lokalne używa wielu progów w celu podzielenia zawartości przesuwającego się okna na $T-1$ przedziałów w celu redukcji ilości kolorów w obrazie. Wynikiem tej operacji jest zmniejszenie gęstości histogramu. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{109}{137}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]	
	\caption{Obraz po zastosowaniu progowania z czterema progami wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-5/multi-local-threshold-image-coffee-4.png}
	\includegraphics[width=8cm, height=8cm]{6-5/multi-local-threshold-coffee-4.png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]	
	\caption{Obraz po zastosowaniu progowania z czterema progami wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-5/multi-local-threshold-image-phone-4.png}
	\includegraphics[width=8cm, height=8cm]{6-5/multi-local-threshold-phone-4.png}
\end{figure}

\section{Progowanie 1-progowe globalne}
\subsection*{Wstęp}
Progowanie 1-progowe globalne dla obrazów barwnych opera się o ustalenie progu dla każdej z trzech barw RGB. Próg jest wyliczany ze wszystkich pikseli na podstawie średniej arytmetycznej. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{140}{161}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po zastosowaniu progowania globalnego wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-6/single-global-threshold-image-coffee.png}
	\includegraphics[width=8cm, height=8cm]{6-6/single-global-threshold-coffee.png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po zastosowaniu progowania globalnego wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-6/single-global-threshold-image-phone.png}
	\includegraphics[width=8cm, height=8cm]{6-6/single-global-threshold-phone.png}
\end{figure}

\section{Progowanie wielo-progowe globalne}
\subsection*{Wstęp}
Progowanie wielo-progowe globalne do stworzenia progów używa maksymalnej wartości ze wszystkich piksli, którą to wartość dzieli później na $T-1$ odcinków i każdy piksel z tych odcinków przypisuje do jednej z $T+1$ wartości progowych. 

\subsection*{Kod algorytmu}
\inputpython{../Source/HistogramColor.py}{164}{186}

\subsection*{Wynik algorytmu}
\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{coffee-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-coffee.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po zastosowaniu progowania globalnego wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-7/multi-global-threshold-image-coffee-4.png}
	\includegraphics[width=8cm, height=8cm]{6-7/multi-global-threshold-coffee-4.png}
\end{figure}

\begin{figure}[H]
	\caption{Obraz bazowy i jego obliczony histogram}
	\includegraphics[width=8cm, height=8cm]{phone-unmodified.jpg}
	\includegraphics[width=8cm, height=8cm]{6-1/calculate-phone.png}
\end{figure}
\begin{figure}[H]
	\caption{Obraz po zastosowaniu progowania globalnego wraz z jego obliczonym histogramem}
	\includegraphics[width=8cm, height=8cm]{6-7/multi-global-threshold-image-phone-4.png}
	\includegraphics[width=8cm, height=8cm]{6-7/multi-global-threshold-phone-4.png}
\end{figure}

\end{document}